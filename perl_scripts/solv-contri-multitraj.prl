#!/usr/bin/perl

#########################################################
#
# Written by Vincent Zoete
#
# Modified by Michel A. Cuendet 
#
# For questions, please contact vincent.zoete@unil.ch
# or michel.cuendet@hotmail.com
#
#########################################################

# prevent warnings for "smartmatch", i.e. operator "~~".
use experimental qw(smartmatch switch);

$mmgbsa_path = $ENV{'mmgbsa_path'};
require "$mmgbsa_path/perl_scripts/time_statistics.prl";

$natoma=`grep \"NATOMA \" data/system.dat | awk '{print \$2}'`;   # Number of atoms in A
chomp $natoma;
print "Total number of atoms in protein : $natoma \n";

$nconf=`grep nframes data/definitions.str | awk '{print \$3}'`; # number of conformations (frames)
chomp $nconf;
print "Number of conformations : $nconf \n";

$temp = `awk '(\$1=="!A")'  data/definitions.str `;
chomp $temp;
my @allA = split(/ /,$temp );
shift @allA;   # Getting rid of the line label in definitions.str

$temp = `awk '(\$1=="!Ares")'  data/definitions.str `;
chomp $temp;
my @resA = split(/ /,$temp );
shift @resA;  # Getting rid of the line label in definitions.str

$cutoff = `awk '(\$1=="!cutoff"){print \$2}'  data/definitions.str `;
chomp $cutoff;
$cutoff2 = $cutoff**2;

$ionconc = `awk '(\$1=="!monovalent_ion_concentration"){print \$2}'  data/definitions.str `;
chomp $ionconc;

#$k=-166*(1/1-1/80);

# Improved loops with less testing for group belonging (slower than actually calculating...)
$do_new_scheme=1;

# Here we implement the Debeye-Huckel model as described in 
# Srinivasan et al., Theo Chem Accts 101(6) : 426, 1999
$celec=-(332.0672/2);# Electric constant in kcal/mol as defined in CHARMM
$eps_w=80;	     # Relecative dielectric constant of water
$inv_eps_w=1.0/$eps_w;
$eps_s=1;            # Relative dielectric constant of solute
$inv_eps_s = 1.0/$eps_s;
# $ionconc=0.154;      # Physiological ion concentration
	             # Recover the original behavior with $ionconc=0
	             
$kappa=0.316*sqrt($ionconc); 	#Debeye screening constant, defined as in 
				# Onufriev et al., Proteins 55 : 383, 2004


# Build dictionary to translate to full-system IRES :
open(IN,"data/definitions.crd") or die "Could not open file data/definitions.crd for reading";
$ii=1;	# Atom numbers start at 1
foreach $line (<IN>) {
    @w=split(" ",$line);
    if ($w[0] eq "*") {next};
    $subindex[$w[0]]=0;
    if ( ($w[0] !~ /\*/) && ($#w >0) ) {
      if ( $w[9] > 0.5 ) {
      	$resnum[$ii]=$w[1];
	# $resname[$ii]=$w[2];    #Not used...
	$atomname[$ii]=$w[3];
	$subindex[$w[0]]=$ii;
	$ii++;
      }
    }
}
close(IN);
$ni = $ii-1;
if ( $ni != $natoma ) {
	die "Mismatch between number of atoms in dictionary ($ni) and in data/system.dat ($natoma) !\n";
}



# Determine type, charges and residue for each atom.
open(IN,"data/charges.crd") or die "Could not open file data/charges.crd for reading" ;
foreach $line (<IN>) {
    @w=split(" ",$line);
    if ( ($w[0] !~ /\*/) && ($#w >0) ) {      
    	$q[$subindex[$w[0]]]=$w[9];
    }
}
close(IN);

# Now the total contribution is calculated in solv-a.inp because we don't do all residues here...
#open(DAT,">total/solv-tot-a.dat");

# Initialize contribution for $nconf conformations.
for $n (1..$nconf) {
foreach $i (@resA) {
      $res_sc[$i][$n]=0;
      $res_bb[$i][$n]=0;
      $res_all[$i][$n]=0; 
}
}

# Calculate contribution for $nconf conformations.
for $n (1..$nconf) {

  print "Treating frame $n \n";

  open(IN,"frames-comp/$n-alpha.crd") or die "Could not open file frames-a/$n-alpha.crd" ;
  foreach $line (<IN>) {
#    if ($line =~ / A1 / or $line =~ / B1 / or $line =~ / A2 / or $line =~ / B2 /) {
      @w=split(" ",$line);
      if ($w[0] eq "*") {next};
      $a[$w[0]]=$w[9];
      $x[$w[0]]=$w[4];
      $y[$w[0]]=$w[5];
      $z[$w[0]]=$w[6];
#    }
  }
  close(IN);


  @contri=0;
   if ($do_new_scheme) {	# Improved loops with less testing for group belonging (slower than actually calculating...)
      for $i (1..$natoma) {
        if ($resnum[$i] ~~ @resA ) {
          for $j (1..$natoma) {		# Here counting from 1 not $i
              $r2=($x[$i]-$x[$j])**2+($y[$i]-$y[$j])**2+($z[$i]-$z[$j])**2;
              if ($r2 > $cutoff2) { next };
	      $a2=$a[$i]*$a[$j];
	      $d = sqrt( $r2 + $a2*exp(-$r2/(8*$a2)));
              $k = $celec*( $inv_eps_s - exp(-$kappa*$d)*$inv_eps_w) ;   # This is the Debeye-Huckel contribution
              $term=$k*$q[$i]*$q[$j]/$d;
              $contri[$i]+= $term;         
          }
        }
      }
  }else{
      for $i (1..$natoma) {
	if ($resnum[$i] ~~ @allA ) {
	  #print "Atom $i Res $resnum[$i]\n";
	  for $j ($i..$natoma) {
            if (($resnum[$i] ~~ @resA ) or ($resnum[$j] ~~ @resA )) {
              $r2=($x[$i]-$x[$j])**2+($y[$i]-$y[$j])**2+($z[$i]-$z[$j])**2;
	      $a2=$a[$i]*$a[$j];
	      $d = sqrt( $r2 + $a2*exp(-$r2/(8*$a2)));
	      $k = $celec*( $inv_eps_s - exp(-$kappa*$d)*$inv_eps_w ) ;   # This is the Debeye-Huckel contribution
	      $term=$k*$q[$i]*$q[$j]/$d;
	      # print "Atom $i $j : charges $q[$i] $q[$j] distance $d term $term\n";
	      if ($i == $j) {
        	$contri[$i]+= $term;
	      } else {
        	$contri[$i]+= $term; # Normally 0.5 for each, but counted twice since loop over triangular matrix
        	$contri[$j]+= $term; # Normally 0.5 for each, but counted twice since loop over triangular matrix
	      }
	    }
	  }
	}
      }
  }

  	
  for $i (1..$natoma) {
    if ($resnum[$i] ~~ @resA ) {
      $res_all[$resnum[$i]][$n]+=$contri[$i];
      if ( $atomname[$i] eq "CA" or  $atomname[$i] eq "HA" or $atomname[$i] eq "C" or $atomname[$i] eq "O" or $atomname[$i] eq "N"  or $atomname[$i] eq "NT" or $atomname[$i] eq "HN" or $atomname[$i] eq "HT1" or $atomname[$i] eq "HT2" or $atomname[$i] eq "HT3" or $atomname[$i] eq "OT1" or $atomname[$i] eq "OT2"or $atomname[$i] eq "HA1" or $atomname[$i] eq "HA2"  ) {
	$res_bb[$resnum[$i]][$n]+=$contri[$i];
      } else {
	$res_sc[$resnum[$i]][$n]+=$contri[$i];
      }
    }
  }

  $all=0; $bb=0; $sc=0;
  open(OUT,">solv/solv-frame-$n.dat")  or die "Could not open file solv/solv-frame-$n.dat\n";
  foreach $i (@resA) {
    $bb+=$res_bb[$i][$n];
    $sc+=$res_sc[$i][$n];
    $all+=$res_all[$i][$n];
    printf OUT ("%4d   %10.4f   %10.4f   %10.4f \n",
		$i,$res_bb[$i][$n],$res_sc[$i][$n],$res_all[$i][$n]);
  }
  print OUT "---------------------------------------------- \n";
  printf OUT ("TOT    %10.4f   %10.4f   %10.4f \n",
	      $bb, $sc, $all);
  close(OUT);

  # printf DAT ("%4d  %10.4f \n",$n,$all);
}


# The following was originally in solv-contri-tot.prl for single-traj. 
# Callculate time statistics
foreach $i (@resA)  {
  ($res_all_mean[$i], $res_all_sd[$i], $res_all_neff[$i], $res_all_err[$i]) = time_statistics_FTZ(@{ $res_all[$i] });
  ($res_bb_mean[$i], $res_bb_sd[$i], $res_bb_neff[$i], $res_bb_err[$i]) = time_statistics_FTZ(@{ $res_bb[$i] });
  ($res_sc_mean[$i], $res_sc_sd[$i], $res_sc_neff[$i], $res_sc_err[$i]) = time_statistics_FTZ(@{ $res_sc[$i] });
  # print "$res_sc_mean[$i] $res_bb_mean[$i] $res_all_mean[$i]\n";
}


foreach $i (@resA)  {
  $filename="solv/solv-res-$i.dat";
  open(OUT,">$filename") or die "Could not open file $filename for writing";
  for $n (1..$nconf) {
    printf OUT ("%4d    %10.4f %10.4f %10.4f \n",
		$n, $res_bb[$i][$n], $res_sc[$i][$n], $res_all[$i][$n]);
  }
  printf OUT "--------------------------------------------\n";
  printf OUT ("AVE     %10.4f %10.4f %10.4f \n",
	      $res_bb_mean[$i], $res_sc_mean[$i], $res_all_mean[$i]);
  printf OUT ("SD      %10.4f %10.4f %10.4f \n",
	      $res_bb_sd[$i], $res_sc_sd[$i], $res_all_sd[$i]);
  printf OUT ("N_eff   %10.4f %10.4f %10.4f \n",
	      $res_bb_neff[$i], $res_sc_neff[$i], $res_all_neff[$i]);	      	      
  printf OUT ("ERR     %10.4f %10.4f %10.4f \n",
	      $res_bb_err[$i], $res_sc_err[$i], $res_all_err[$i]);	      	      
  close(OUT);
}


open(OUT,">solv/solv-res.dat")or die "Could not open file solv/solv-res.dat for writing";
foreach $i (@resA)  {
  printf OUT ("%4d    %10.4f %10.4f %10.4f    %10.4f %10.4f %10.4f  \n",
	      $i, $res_bb_mean[$i], $res_sc_mean[$i], $res_all_mean[$i],  $res_bb_err[$i], $res_sc_err[$i], $res_all_err[$i]);
  $res_bb_tot+=$res_bb_mean[$i];
  $res_sc_tot+=$res_sc_mean[$i];
  $res_all_tot+=$res_all_mean[$i];
}
printf OUT "--------------------------------------------\n";
printf OUT ("TOT     %10.4f %10.4f %10.4f \n",
	    $res_bb_tot, $res_sc_tot, $res_all_tot);


















