#!/usr/bin/perl

#########################################################
#
# Written by Vincent Zoete
#
# Modified by Michel A. Cuendet 
#
# For questions, please contact vincent.zoete@unil.ch
# or michel.cuendet@unil.ch
#
#########################################################

# Calculate the free energy contributions and errors for a group of residues
# The group if defined in the !group entry in the data/definitions.str file
#
# Effective sample size in a correlated time series
# Estimated from AR(1) process. 
# According to :
# Zwiers and Storch, Taking Serial Correlation into Account in Tests of the Mean
# Journal of Climate 8 : 336 (1995).

# prevent warnings for "smartmatch", i.e. operator "~~".
use experimental qw(smartmatch switch);


$natom=`grep \"NATOM \" data/system.dat | awk '{print \$2}'`;   # Number of atoms in the system
chomp $natom;
print "Total number of atoms in the system : $natom \n";

$nconf=`grep nframes data/definitions.str | awk '(\$1=="SET"){print \$3}'`; # number of conformations (frames)
chomp $nconf;
print "Number of conformations : $nconf \n";


$nres=`grep lastresb data/definitions.str | awk '(\$1=="SET"){print \$3}'`; # Total number of residues.
chomp $nres;
print "Total number of residues : $nres \n";

$temp = `awk '(\$1=="!Ares")'  data/definitions.str `;
chomp $temp;
my @resA = split(/ /,$temp );
shift @resA;  # Getting rid of the line label in definitions.str
$nresA = scalar(@resA);

$temp = `awk '(\$1=="!Bres") '  data/definitions.str `;
chomp $temp;
my @resB = split(/ /,$temp );
shift @resB;  # Getting rid of the line label in definitions.str
$nresB = scalar(@resB);

my @resAB = @resA;
push( @resAB, @resB) ; 
$nresAB = $nresA + $nresB;


$temp = `awk '(\$1=="!group") '  data/definitions.str `;
chomp $temp;
my @group = split(/ /,$temp );
shift @group;  # Getting rid of the line label in definitions.str
$ngroup = scalar(@group);

print "Number of residues in analysis group : $ngroup \n";


open(IN,"data/charges.crd");
foreach $line (<IN>) {
  # Look only at C alphas, P for lipids, O3 for cholesterol, Na for sodium ions...
  if ( ($line =~ /CA /) or ($line =~ / O3 /) or ($line =~ / P /) or ($line =~ / SOD /) ) {
    @w=split(" " ,$line);
    $name[$w[1]]=$w[7]." ".$w[2].$w[8];
  }
  $resnum[$w[0]]=$w[1];
  $resname[$w[0]]=$w[2];
  $atomname[$w[0]]=$w[3];
  if ( $atomname[$i] eq "CA" or  $atomname[$i] eq "HA" or $atomname[$i] eq "C" or $atomname[$i] eq "O" or $atomname[$i] eq "N"  or $atomname[$i] eq "NT" or $atomname[$i] eq "HN" or $atomname[$i] eq "HT1" or $atomname[$i] eq "HT2" or $atomname[$i] eq "HT3" or $atomname[$i] eq "OT1" or $atomname[$i] eq "OT2"or $atomname[$i] eq "HA1" or $atomname[$i] eq "HA2") {
    $is_bb[$i]=1;
  } else {
    $is_bb[$i]=0;
  }
}

#===================================================================================
#Inter

print "Loading inter ... \n";

for $n (1..$nconf) {
  $nrA=0;
  open(IN,"inter/inter-byres-$n-a.dat") or die "Could not open file inter-byres-$n-b.dat \n";
  foreach $line (<IN>) {
    @w=split(" ",$line);
    $res_vdw_bb[$w[0]][$n]=$w[1];
    $res_elec_bb[$w[0]][$n]=$w[2];
    $res_vdw_sc[$w[0]][$n]=$w[3];
    $res_elec_sc[$w[0]][$n]=$w[4];
    $nrA+=1;
  }
  close(IN);
  $nrB=0;
  open(IN,"inter/inter-byres-$n-b.dat") or die "Could not open file inter-byres-$n-b.dat \n";
  foreach $line (<IN>) {
    @w=split(" ",$line);
    $res_vdw_bb[$w[0]][$n]+=$w[1];
    $res_elec_bb[$w[0]][$n]+=$w[2];
    $res_vdw_sc[$w[0]][$n]+=$w[3];
    $res_elec_sc[$w[0]][$n]+=$w[4];
    $nrB+=1;
  }

  if ( $nrA != $nresA ) { die "Frame $n : number of inter values in part A ($nrA) does not match definitions.str ($nresA) !!" ;}
  if ( $nrB != $nresB ) { die "Frame $n : number of inter values in part B ($nrB) does not match definitions.str ($nresB) !!" ;}

  close(IN);

}

#print "$res_elec_bb[81][1] $res_elec_sc[81][1]\n";

#===================================================================================
#Solv
print "Loading solv ... \n";

# Do in A :       
@res_bb_mean=0; @res_sc_mean=0; @res_all_mean=0;
for $f (1..$nconf) {
  open(IN,"solv-a/solv-a-frame-$f.dat") or die "Could not open file solv-a/solv-a-frame-$f.dat";
  foreach $line (<IN>) {
    if ($line !~/TOT/) {
      @w=split(" ",$line);
      $solv_a_bb[$w[0]][$f]=$w[1];
      $solv_a_sc[$w[0]][$f]=$w[2];
      $solv_a_all[$w[0]][$f]=$w[3];
    }
  }
}

# Do in B :    
@res_bb_mean=0; @res_sc_mean=0; @res_all_mean=0;
for $f (1..$nconf) {
  open(IN,"solv-b/solv-b-frame-$f.dat") or die "Could not open file solv-b/solv-b-frame-$f.dat";
  foreach $line (<IN>) {
    if ($line !~/TOT/) {
      @w=split(" ",$line);
      $solv_b_bb[$w[0]][$f]=$w[1];
      $solv_b_sc[$w[0]][$f]=$w[2];
      $solv_b_all[$w[0]][$f]=$w[3];
    }
  }
}

#Do in complex :   
@res_bb_mean=0; @res_sc_mean=0; @res_all_mean=0;
for $f (1..$nconf) {
  open(IN,"solv-comp/solv-comp-frame-$f.dat") or die "Could not open file solv-comp/solv-comp-frame-$f.dat";
  foreach $line (<IN>) {
    if ($line !~/TOT/) {
      @w=split(" ",$line);
      $solv_comp_bb[$w[0]][$f]=$w[1];
      $solv_comp_sc[$w[0]][$f]=$w[2];
      $solv_comp_all[$w[0]][$f]=$w[3];
    }
  }
}

#$temp = $solv_comp_all[81][1]- $solv_a_all[81][1] - $solv_b_all[81][1];
#print "$solv_comp_all[81][1] $solv_a_all[81][1]  $solv_b_all[81][1]  $temp \n";

#===================================================================================
# Surf 
# Here we need to sum over atoms to get residue (sc /bb) contributions.

print "Loading surf ... \n";
# Do sas in A :   
foreach $i (@resA)  {
  $filename="sas-a/sas-a-res-$i.dat";
  open(IN,$filename) or die "Could not open file $filename";
  foreach $line (<IN>) {
    @w=split(" ",$line);
    $sas_a_bb[$i][$w[0]] =$w[1];
    $sas_a_sc[$i][$w[0]] =$w[2];
    $sas_a_all[$i][$w[0]] =$w[3];
  }
}
#print "sas-a $sas_a_bb[81][1] $sas_a_sc[81][1] $sas_a_all[81][1] \n";


# Do sas in B :  
foreach $i (@resB)  {
  $filename="sas-b/sas-b-res-$i.dat";
  open(IN,$filename) or die "Could not open file $filename";
  foreach $line (<IN>) {
    @w=split(" ",$line);
    $sas_b_bb[$i][$w[0]] =$w[1];
    $sas_b_sc[$i][$w[0]] =$w[2];
    $sas_b_all[$i][$w[0]] =$w[3];
  }
}
#print "sas-b $sas_b_bb[81][1] $sas_b_sc[81][1] $sas_b_all[81][1] \n";


# Do sas in complex :  
foreach $i (@resAB)  {
  $filename="sas-comp/sas-comp-res-$i.dat";
  open(IN,$filename) or die "Could not open file $filename";
  foreach $line (<IN>) {
    @w=split(" ",$line);
    $sas_comp_bb[$i][$w[0]] =$w[1];
    $sas_comp_sc[$i][$w[0]] =$w[2];
    $sas_comp_all[$i][$w[0]] =$w[3];
  }
}
#print "sas-comp $sas_comp_bb[81][1] $sas_comp_sc[81][1] $sas_comp_all[81][1] \n";



# ====================================================================================================
# Calculate time series for entire dg
print "Calculating ... \n";

mkdir "dg";


my @dg_sc_group=0;	# Arrays with all time points for the group
my @dg_bb_group=0;
my @dg_all_group=0;

foreach $i (@group)  {
   
  
  for $n (1..$nconf) {

    $vdw_sc = 0.5*$res_vdw_sc[$i][$n];
    $elec_sc = 0.5*$res_elec_sc[$i][$n];
    $solv_sc = $solv_comp_sc[$i][$n] - $solv_a_sc[$i][$n] - $solv_b_sc[$i][$n];
    $np_sc =  0.0072*($sas_comp_sc[$i][$n] - $sas_a_sc[$i][$n] -$sas_b_sc[$i][$n]) ;
    $dg_sc_group[$n] += $vdw_sc + $elec_sc + $solv_sc  + $np_sc ;

    $vdw_bb = 0.5*$res_vdw_bb[$i][$n];
    $elec_bb = 0.5*$res_elec_bb[$i][$n];
    $solv_bb = $solv_comp_bb[$i][$n] - $solv_a_bb[$i][$n] - $solv_b_bb[$i][$n];
    $np_bb =  0.0072*($sas_comp_bb[$i][$n] - $sas_a_bb[$i][$n] -$sas_b_bb[$i][$n]) ;
    $dg_bb_group[$n] += $vdw_bb + $elec_bb + $solv_bb  + $np_bb ;

    $vdw_all = $vdw_sc + $vdw_bb ;
    $elec_all = $elec_sc + $elec_bb ;
    $solv_all = $solv_comp_all[$i][$n] - $solv_a_all[$i][$n] - $solv_b_all[$i][$n];
    $np_all =  0.0072*($sas_comp_all[$i][$n] - $sas_a_all[$i][$n] -$sas_b_all[$i][$n]) ;
    $dg_all_group[$n] += $vdw_all + $elec_all + $solv_all  + $np_all ;
  

  
  }
}

open(OUT,">binding_group_stat.dat");

my $dg_sc_tot=0;
my $dg_bb_tot=0;
my $dg_all_tot=0;
my $dg2_sc_tot=0;
my $dg2_bb_tot=0;
my $dg2_all_tot=0;

for $n (1..$nconf) {

     printf OUT ("%4d    %10.4f %10.4f %10.4f \n",
                $n, $dg_bb_group[$n], $dg_sc_group[$n], $dg_all_group[$n]);
    
    $dg_sc_tot+=$dg_sc_group[$n];
    $dg_bb_tot+=$dg_bb_group[$n];
    $dg_all_tot+=$dg_all_group[$n];
    $dg2_sc_tot+=$dg_sc_group[$n]**2;
    $dg2_bb_tot+=$dg_bb_group[$n]**2;
    $dg2_all_tot+=$dg_all_group[$n]**2;
}
 
$dg_sc_mean = $dg_sc_tot/$nconf;
$dg_bb_mean = $dg_bb_tot/$nconf;
$dg_all_mean = $dg_all_tot/$nconf;


# Unbiased standard deviation estimate 
$dg_sc_sd = sqrt( ( $dg2_sc_tot - $nconf*$dg_sc_mean**2 ) / ($nconf -1) );
$dg_bb_sd = sqrt( ( $dg2_bb_tot - $nconf*$dg_bb_mean**2 ) / ($nconf -1) );
$dg_all_sd = sqrt( ( $dg2_all_tot - $nconf*$dg_all_mean**2 ) / ($nconf -1) );

# Effective sample size in an AR(1)  correlated time series according to :
# Zwiers and Storch, Taking Serial Correlation into Account in Tests of the Mean, Journal of Climate 8 : 336 (1995).

# Now that we have the mean, we can calculate the moments :
my $dg2_sc_norm_tot=0;
my $dg2_bb_norm_tot=0;
my $dg2_all_norm_tot=0;
my $dg2_shift_sc_tot=0;
my $dg2_shift_bb_tot=0;
my $dg2_shift_all_tot=0;
for $n (1..$nconf) {
  $dg2_sc_norm_tot+=($dg_sc_group[$n] -  $dg_sc_mean)**2; 
  $dg2_bb_norm_tot+=($dg_bb_group[$n] -  $dg_bb_mean)**2;
  $dg2_all_norm_tot+=($dg_all_group[$n] -  $dg_all_mean)**2;

  if ($n >1) {
     $dg2_shift_sc_tot+=($dg_sc_group[$n] -  $dg_sc_mean) * ($dg_sc_old -  $dg_sc_mean);
     $dg2_shift_bb_tot+=($dg_bb_group[$n] -  $dg_bb_mean) * ($dg_bb_old -  $dg_bb_mean);
     $dg2_shift_all_tot+=($dg_all_group[$n] -  $dg_all_mean) * ($dg_all_old -  $dg_all_mean);
  }

  $dg_sc_old=$dg_sc_group[$n];
  $dg_bb_old=$dg_bb_group[$n];
  $dg_all_old=$dg_all_group[$n];
}

# For each, calculate n_effective and standard error.
if ($dg2_sc_tot > 0) {
  $r1_sc = $dg2_shift_sc_tot / $dg2_sc_norm_tot;
  $n_eff_sc = $nconf * (1-$r1_sc) / (1+$r1_sc) ;
  if ( $n_eff_sc gt $nconf) {$n_eff_sc = $nconf};
  $dg_sc_err = $dg_sc_sd / sqrt($n_eff_sc ) ; 
}else{
  $n_eff_sc = 0;
  $dg_sc_err = 0;
}

if ($dg2_bb_tot > 0) {
  $r1_bb = $dg2_shift_bb_tot / $dg2_bb_norm_tot;
  $n_eff_bb = $nconf * (1-$r1_bb) / (1+$r1_bb) ;
  if ( $n_eff_bb gt $nconf) {$n_eff_bb = $nconf};
  $dg_bb_err = $dg_bb_sd / sqrt($n_eff_bb ) ;
}else{
  $n_eff_bb = 0;
  $dg_bb_err = 0;
}

if ($dg2_all_tot > 0) {
  $r1_all = $dg2_shift_all_tot / $dg2_all_norm_tot;
  $n_eff_all = $nconf * (1-$r1_all) / (1+$r1_all) ;
  if ( $n_eff_all gt $nconf) {$n_eff_all = $nconf};
  $dg_all_err = $dg_all_sd / sqrt($n_eff_all ) ;
}else{
  $n_eff_all = 0;
  $dg_all_err = 0;
}

printf OUT "# --------------------------------------------\n";
printf OUT ("# TOT	%10.4f %10.4f %10.4f \n",
	    $dg_bb_mean, $dg_sc_mean, $dg_all_mean);
printf OUT ("# SD	%10.4f %10.4f %10.4f \n",
	    $dg_bb_sd, $dg_sc_sd, $dg_all_sd);
printf OUT ("# N_eff   %10.4f %10.4f %10.4f \n",
	    $n_eff_bb, $n_eff_sc, $n_eff_all);
printf OUT ("# ERR     %10.4f %10.4f %10.4f \n",
	    $dg_bb_err, $dg_sc_err, $dg_all_err);
close(OUT);



