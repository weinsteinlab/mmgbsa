#!/usr/bin/perl


#########################################################
#
# Written by Vincent Zoete
#
# Modified by Michel A. Cuendet 
#
# For questions, please contact vincent.zoete@unil.ch
# or michel.cuendet@hotmail.com
#
#########################################################

# prevent warnings for "smartmatch", i.e. operator "~~".
# use experimental qw(smartmatch switch);


$natom=`grep \"NATOM \" data/system.dat | awk '{print \$2}'`;   # Number of atoms in the system
chomp $natom;
print "Total number of atoms in the system : $natom \n";

$nconf=`grep nframes data/definitions.str | awk '{print \$3}'`; # number of conformations (frames)
chomp $nconf;
print "Number of conformations : $nconf \n";

$do_membrane=`grep domem  data/definitions.str | awk '{print \$3}'`; # Do HDGB for membranes?
chomp $do_membrane;

$temp = `awk '(\$1=="!Ares")'  data/definitions.str `;
chomp $temp;
my @resA = split(/ /,$temp );
shift @resA;  # Getting rid of the line label in definitions.str
$nresA = scalar(@resA);

$temp = `awk '(\$1=="!Bres") '  data/definitions.str `;
chomp $temp;
my @resB = split(/ /,$temp );
shift @resB;  # Getting rid of the line label in definitions.str
$nresB = scalar(@resB);

my @resAB = @resA;
push( @resAB, @resB) ;
$nresAB = $nresA + $nresB;


# Determine type, charges and residue for each atom.

open(IN,"data/charges.crd");
foreach $line (<IN>) {
#  if ($line =~ / A1 / or $line =~ / B1 / or $line =~ / A2 / or $line =~ / B2 /) {
    @w=split(" ",$line);
    $q[$w[0]]=$w[9];
    $resnum[$w[0]]=$w[1];
    $resname[$w[0]]=$w[2];
    $atomname[$w[0]]=$w[3];
#  }
}
close(IN);
$lastresnum=$resnum[$natom];


# Load gamma profile for HDGB

if ( $do_membrane eq "YES" ) {
  print "Doing membrane non-polar correction. \n";
  $i = 0;
  open(IN,"data/hdgb_gamma_switch.dat");
  foreach $line (<IN>) {
    if ( $i > 0 ) {
        @w=split(" ",$line);
        $z_ref[$i]=$w[0];
        $S_ref[$i]=$w[1];
    }
    $i += 1;
  }
  close(IN);
  $n_z_ref = $i-1;
  $last_z_ref = $z_ref[$n_z_ref];
}
print "Loaded gamma switch file. Last Z ref : $last_z_ref\n";


# Calculate contribution for $nconf conformations.

for $n (1..$nconf) {

  open(IN,"frames-comp/$n-sas.crd") or die "Could not open file frames-comp/$n-sas.crd";
  foreach $line (<IN>) {
#    if ($line =~ / A1 / or $line =~ / B1 / or $line =~ / A2 / or $line =~ / B2 /) {
      @w=split(" ",$line);
      $sas[$w[0]]=$w[9];
      $z[$w[0]]=$w[6];
#    }
  }
  close(IN);

  for $i (1..$natom) {
    if ($resnum[$i] ~~ @resAB ) {  # This does not work with older perl versions. 
    
      # Do the interpolation of the switch funtion for HDGB
      if ( $do_membrane eq "YES" and $sas[$i] > 0.0 ) {
        if ( abs($z[$i]) > $last_z_ref ) {
            $S = 1.0;
        } else {
            $z_ref_old=0.0;
            $S_ref_old=$S_ref[1] ;
            for $j (2..$n_z_ref) {
                if ( abs($z[$i]) < $z_ref[$j] ) {
                    $proportion = ( abs($z[$i]) - $z_ref_old ) / ($z_ref[$j] - $z_ref_old ) ;
                    $S = $S_ref_old + $proportion * ($S_ref[$j] - $S_ref_old );
                    last;
                }
                $z_ref_old = $z_ref[$j];
                $S_ref_old = $S_ref[$j];
            }
        }
        $this = $S * $sas[$i];
        # print "Atom $i  sas : $sas[$i]  z : $z[$i]  S ; $S  this : $this \n";
      }else{
        $this=$sas[$i];
      }

      # Allocate to residue
      $res_all[$resnum[$i]][$n]+=$this;
      $res_all_mean[$resnum[$i]]+=$this;
      if ( $atomname[$i] eq "CA" or  $atomname[$i] eq "HA" or $atomname[$i] eq "C" or $atomname[$i] eq "O" or $atomname[$i] eq "N"  or $atomname[$i] eq "NT" or $atomname[$i] eq "HN" or $atomname[$i] eq "HT1" or $atomname[$i] eq "HT2" or $atomname[$i] eq "HT3" or $atomname[$i] eq "OT1" or $atomname[$i] eq "OT2"or $atomname[$i] eq "HA1" or $atomname[$i] eq "HA2") {
        $res_bb[$resnum[$i]][$n]+=$this;
        $res_bb_mean[$resnum[$i]]+=$this;
      } else {
        $res_sc[$resnum[$i]][$n]+=$this;
        $res_sc_mean[$resnum[$i]]+=$this;
      }

    }
  }

}

foreach $i (@resAB) {
  $res_all_mean[$i]=$res_all_mean[$i]/$nconf;
  $res_bb_mean[$i]=$res_bb_mean[$i]/$nconf;
  $res_sc_mean[$i]=$res_sc_mean[$i]/$nconf;
  for $n (1..$nconf) {
    $res_all_sd[$i]+=($res_all[$i][$n]-$res_all_mean[$i])**2;
    $res_bb_sd[$i]+=($res_bb[$i][$n]-$res_bb_mean[$i])**2;
    $res_sc_sd[$i]+=($res_sc[$i][$n]-$res_sc_mean[$i])**2;
  }
  $res_all_sd[$i]=sqrt($res_all_sd[$i]/$nconf);
  $res_bb_sd[$i]=sqrt($res_bb_sd[$i]/$nconf);
  $res_sc_sd[$i]=sqrt($res_sc_sd[$i]/$nconf);
}


foreach $i (@resAB)  {
  $filename="sas-comp/sas-comp-res-$i.dat";
  open(OUT,">$filename");
  for $n (1..$nconf) {
    printf OUT ("%4d    %10.4f %10.4f %10.4f \n",
		$n, $res_bb[$i][$n], $res_sc[$i][$n], $res_all[$i][$n]);
  }
  printf OUT "--------------------------------------------\n";
  printf OUT ("TOT     %10.4f %10.4f %10.4f \n",
	      $res_bb_mean[$i], $res_sc_mean[$i], $res_all_mean[$i]);
  printf OUT ("SD      %10.4f %10.4f %10.4f \n",
	      $res_bb_sd[$i], $res_sc_sd[$i], $res_all_sd[$i]);
  close(OUT);
}


open(OUT,">sas-comp/sas-comp-res.dat");
foreach $i (@resAB)  {
  printf OUT ("%4d    %10.4f %10.4f %10.4f \n",
	      $i, $res_bb_mean[$i], $res_sc_mean[$i], $res_all_mean[$i]);
  $res_bb_tot+=$res_bb_mean[$i];
  $res_sc_tot+=$res_sc_mean[$i];
  $res_all_tot+=$res_all_mean[$i];
}
printf OUT "--------------------------------------------\n";
printf OUT ("TOT     %10.4f %10.4f %10.4f \n",
	    $res_bb_tot, $res_sc_tot, $res_all_tot);
